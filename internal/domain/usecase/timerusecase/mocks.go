// Code generated by MockGen. DO NOT EDIT.
// Source: internal/domain/usecase/timerusecase/usecase.go

// Package timerusecase is a generated GoMock package.
package timerusecase

import (
	context "context"
	reflect "reflect"

	notification "github.com/Tap-Team/timerapi/internal/model/notification"
	timerevent "github.com/Tap-Team/timerapi/internal/model/timerevent"
	timermodel "github.com/Tap-Team/timerapi/internal/model/timermodel"
	gomock "github.com/golang/mock/gomock"
	uuid "github.com/google/uuid"
)

// MockTimerStorage is a mock of TimerStorage interface.
type MockTimerStorage struct {
	ctrl     *gomock.Controller
	recorder *MockTimerStorageMockRecorder
}

// MockTimerStorageMockRecorder is the mock recorder for MockTimerStorage.
type MockTimerStorageMockRecorder struct {
	mock *MockTimerStorage
}

// NewMockTimerStorage creates a new mock instance.
func NewMockTimerStorage(ctrl *gomock.Controller) *MockTimerStorage {
	mock := &MockTimerStorage{ctrl: ctrl}
	mock.recorder = &MockTimerStorageMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTimerStorage) EXPECT() *MockTimerStorageMockRecorder {
	return m.recorder
}

// DeleteTimer mocks base method.
func (m *MockTimerStorage) DeleteTimer(ctx context.Context, id uuid.UUID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteTimer", ctx, id)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteTimer indicates an expected call of DeleteTimer.
func (mr *MockTimerStorageMockRecorder) DeleteTimer(ctx, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteTimer", reflect.TypeOf((*MockTimerStorage)(nil).DeleteTimer), ctx, id)
}

// InsertCountdownTimer mocks base method.
func (m *MockTimerStorage) InsertCountdownTimer(ctx context.Context, creator int64, timer *timermodel.CreateTimer) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertCountdownTimer", ctx, creator, timer)
	ret0, _ := ret[0].(error)
	return ret0
}

// InsertCountdownTimer indicates an expected call of InsertCountdownTimer.
func (mr *MockTimerStorageMockRecorder) InsertCountdownTimer(ctx, creator, timer interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertCountdownTimer", reflect.TypeOf((*MockTimerStorage)(nil).InsertCountdownTimer), ctx, creator, timer)
}

// InsertDateTimer mocks base method.
func (m *MockTimerStorage) InsertDateTimer(ctx context.Context, creator int64, timer *timermodel.CreateTimer) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertDateTimer", ctx, creator, timer)
	ret0, _ := ret[0].(error)
	return ret0
}

// InsertDateTimer indicates an expected call of InsertDateTimer.
func (mr *MockTimerStorageMockRecorder) InsertDateTimer(ctx, creator, timer interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertDateTimer", reflect.TypeOf((*MockTimerStorage)(nil).InsertDateTimer), ctx, creator, timer)
}

// Subscribe mocks base method.
func (m *MockTimerStorage) Subscribe(ctx context.Context, timerId uuid.UUID, userId int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Subscribe", ctx, timerId, userId)
	ret0, _ := ret[0].(error)
	return ret0
}

// Subscribe indicates an expected call of Subscribe.
func (mr *MockTimerStorageMockRecorder) Subscribe(ctx, timerId, userId interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockTimerStorage)(nil).Subscribe), ctx, timerId, userId)
}

// Timer mocks base method.
func (m *MockTimerStorage) Timer(ctx context.Context, timerId uuid.UUID) (*timermodel.Timer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Timer", ctx, timerId)
	ret0, _ := ret[0].(*timermodel.Timer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Timer indicates an expected call of Timer.
func (mr *MockTimerStorageMockRecorder) Timer(ctx, timerId interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Timer", reflect.TypeOf((*MockTimerStorage)(nil).Timer), ctx, timerId)
}

// Unsubscribe mocks base method.
func (m *MockTimerStorage) Unsubscribe(ctx context.Context, timerId uuid.UUID, userId int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unsubscribe", ctx, timerId, userId)
	ret0, _ := ret[0].(error)
	return ret0
}

// Unsubscribe indicates an expected call of Unsubscribe.
func (mr *MockTimerStorageMockRecorder) Unsubscribe(ctx, timerId, userId interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unsubscribe", reflect.TypeOf((*MockTimerStorage)(nil).Unsubscribe), ctx, timerId, userId)
}

// UpdateTimer mocks base method.
func (m *MockTimerStorage) UpdateTimer(ctx context.Context, timerId uuid.UUID, timerSettings *timermodel.TimerSettings) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateTimer", ctx, timerId, timerSettings)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateTimer indicates an expected call of UpdateTimer.
func (mr *MockTimerStorageMockRecorder) UpdateTimer(ctx, timerId, timerSettings interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateTimer", reflect.TypeOf((*MockTimerStorage)(nil).UpdateTimer), ctx, timerId, timerSettings)
}

// UserCreatedTimers mocks base method.
func (m *MockTimerStorage) UserCreatedTimers(ctx context.Context, userId int64, offset, limit int) ([]*timermodel.Timer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UserCreatedTimers", ctx, userId, offset, limit)
	ret0, _ := ret[0].([]*timermodel.Timer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UserCreatedTimers indicates an expected call of UserCreatedTimers.
func (mr *MockTimerStorageMockRecorder) UserCreatedTimers(ctx, userId, offset, limit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UserCreatedTimers", reflect.TypeOf((*MockTimerStorage)(nil).UserCreatedTimers), ctx, userId, offset, limit)
}

// UserSubscriptions mocks base method.
func (m *MockTimerStorage) UserSubscriptions(ctx context.Context, userId int64, offset, limit int) ([]*timermodel.Timer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UserSubscriptions", ctx, userId, offset, limit)
	ret0, _ := ret[0].([]*timermodel.Timer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UserSubscriptions indicates an expected call of UserSubscriptions.
func (mr *MockTimerStorageMockRecorder) UserSubscriptions(ctx, userId, offset, limit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UserSubscriptions", reflect.TypeOf((*MockTimerStorage)(nil).UserSubscriptions), ctx, userId, offset, limit)
}

// UserTimers mocks base method.
func (m *MockTimerStorage) UserTimers(ctx context.Context, userId int64, limit, offset int) ([]*timermodel.Timer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UserTimers", ctx, userId, limit, offset)
	ret0, _ := ret[0].([]*timermodel.Timer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UserTimers indicates an expected call of UserTimers.
func (mr *MockTimerStorageMockRecorder) UserTimers(ctx, userId, limit, offset interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UserTimers", reflect.TypeOf((*MockTimerStorage)(nil).UserTimers), ctx, userId, limit, offset)
}

// MockSubscriberCacheStorage is a mock of SubscriberCacheStorage interface.
type MockSubscriberCacheStorage struct {
	ctrl     *gomock.Controller
	recorder *MockSubscriberCacheStorageMockRecorder
}

// MockSubscriberCacheStorageMockRecorder is the mock recorder for MockSubscriberCacheStorage.
type MockSubscriberCacheStorageMockRecorder struct {
	mock *MockSubscriberCacheStorage
}

// NewMockSubscriberCacheStorage creates a new mock instance.
func NewMockSubscriberCacheStorage(ctrl *gomock.Controller) *MockSubscriberCacheStorage {
	mock := &MockSubscriberCacheStorage{ctrl: ctrl}
	mock.recorder = &MockSubscriberCacheStorageMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSubscriberCacheStorage) EXPECT() *MockSubscriberCacheStorageMockRecorder {
	return m.recorder
}

// DeleteTimer mocks base method.
func (m *MockSubscriberCacheStorage) DeleteTimer(ctx context.Context, id uuid.UUID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteTimer", ctx, id)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteTimer indicates an expected call of DeleteTimer.
func (mr *MockSubscriberCacheStorageMockRecorder) DeleteTimer(ctx, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteTimer", reflect.TypeOf((*MockSubscriberCacheStorage)(nil).DeleteTimer), ctx, id)
}

// Subscribe mocks base method.
func (m *MockSubscriberCacheStorage) Subscribe(ctx context.Context, timerId uuid.UUID, userIds ...int64) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, timerId}
	for _, a := range userIds {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Subscribe", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Subscribe indicates an expected call of Subscribe.
func (mr *MockSubscriberCacheStorageMockRecorder) Subscribe(ctx, timerId interface{}, userIds ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, timerId}, userIds...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockSubscriberCacheStorage)(nil).Subscribe), varargs...)
}

// TimerSubscribers mocks base method.
func (m *MockSubscriberCacheStorage) TimerSubscribers(ctx context.Context, timerId uuid.UUID) (timermodel.Subscribers, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TimerSubscribers", ctx, timerId)
	ret0, _ := ret[0].(timermodel.Subscribers)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TimerSubscribers indicates an expected call of TimerSubscribers.
func (mr *MockSubscriberCacheStorageMockRecorder) TimerSubscribers(ctx, timerId interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TimerSubscribers", reflect.TypeOf((*MockSubscriberCacheStorage)(nil).TimerSubscribers), ctx, timerId)
}

// Unsubscribe mocks base method.
func (m *MockSubscriberCacheStorage) Unsubscribe(ctx context.Context, timerId uuid.UUID, userId int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unsubscribe", ctx, timerId, userId)
	ret0, _ := ret[0].(error)
	return ret0
}

// Unsubscribe indicates an expected call of Unsubscribe.
func (mr *MockSubscriberCacheStorageMockRecorder) Unsubscribe(ctx, timerId, userId interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unsubscribe", reflect.TypeOf((*MockSubscriberCacheStorage)(nil).Unsubscribe), ctx, timerId, userId)
}

// MockEventSender is a mock of EventSender interface.
type MockEventSender struct {
	ctrl     *gomock.Controller
	recorder *MockEventSenderMockRecorder
}

// MockEventSenderMockRecorder is the mock recorder for MockEventSender.
type MockEventSenderMockRecorder struct {
	mock *MockEventSender
}

// NewMockEventSender creates a new mock instance.
func NewMockEventSender(ctrl *gomock.Controller) *MockEventSender {
	mock := &MockEventSender{ctrl: ctrl}
	mock.recorder = &MockEventSenderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEventSender) EXPECT() *MockEventSenderMockRecorder {
	return m.recorder
}

// Send mocks base method.
func (m *MockEventSender) Send(event timerevent.TimerEvent) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Send", event)
}

// Send indicates an expected call of Send.
func (mr *MockEventSenderMockRecorder) Send(event interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Send", reflect.TypeOf((*MockEventSender)(nil).Send), event)
}

// MockNotificationSender is a mock of NotificationSender interface.
type MockNotificationSender struct {
	ctrl     *gomock.Controller
	recorder *MockNotificationSenderMockRecorder
}

// MockNotificationSenderMockRecorder is the mock recorder for MockNotificationSender.
type MockNotificationSenderMockRecorder struct {
	mock *MockNotificationSender
}

// NewMockNotificationSender creates a new mock instance.
func NewMockNotificationSender(ctrl *gomock.Controller) *MockNotificationSender {
	mock := &MockNotificationSender{ctrl: ctrl}
	mock.recorder = &MockNotificationSenderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNotificationSender) EXPECT() *MockNotificationSenderMockRecorder {
	return m.recorder
}

// Send mocks base method.
func (m *MockNotificationSender) Send(notification notification.Notification) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Send", notification)
}

// Send indicates an expected call of Send.
func (mr *MockNotificationSenderMockRecorder) Send(notification interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Send", reflect.TypeOf((*MockNotificationSender)(nil).Send), notification)
}
